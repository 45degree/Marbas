# 渲染硬件接口(RHI)

渲染硬件接口是对不同平台的图形api的封装, 设计目的是为了方便切换不同平台API, 目前只支持OPENGL,
后续将支持VULKAN。

[toc]

## 接口定义

### Swap chain

Swap Chain用来在屏幕上展示最终的渲染结果, 其内部负责在每一个显示器的Vblank(可以理解为一次刷新)向
`Surface`输送渲染好的画面，然后把这个画面(已经没用了)来回收, 画面的数量由渲染API决定(OpenGL并没有
显示的定义Swap Chain, 所以只有一个)。

SwapChain的配置参数如下:
  1. width, height
  2. 是否开启垂直同步
  3. Window

``` cpp
class SwapChain {
  std::vector<std::shared_ptr<Texture>> m_textures;

public:
  SwapChain(int width, int height, GLFWWindows* windows);
  std::shared_ptr<Texture> GetCurrentTexture() {
    // IMPL
  }
};
```

需要注意的是, 为了将一个Texture显示到`Surface`, 应该将这张`texture`作为默认`framebuffer`的
`colorAttachment`

### [buffer](https://www.khronos.org/opengl/wiki/Buffer_Object)

#### VBO(Vertex Buffer Object 顶点缓冲)

VBO是GPU中用于保存顶点属性数据的缓冲，在创建时需要指定大小。

一个顶点可能包含多个属性，例如:

``` cpp

struct Vertex {
  glm::vec2 pos;
  glm::vec3 color;
};

const std::vector<Vertex> vertices = {
  { { 0.0f, -0.5f}, {1.0f, 0.0f, 0.0f} }, 
  { { 0.5f,  0.5f}, {0.0f, 1.0f, 0.0f} }, 
  { {-0.5f,  0.5f}, {0.0f, 0.0f, 1.0f} } 
};

```

使用`VertexAttributeDescription`来解释顶点属性并绑定到着色器中

```cpp

struct VertexInputDescription {
  std::vector<VertexAttributeDescription> attributeDescription;
};

struct VertexAttributeDescription {
  uint32_t location;
  ElementType mateType;
  size_t typeBytes;
  size_t count;
  bool normalized;
  size_t stride;
  size_t offset;
};

VertexInputDescription inputDescription;
void* data = ...;
size_t size = ...;

auto* vbo = std::make_unique<VertexBuffer>(1000);
vbo->StVertexInputDescription(inputDescription);
vbo->SetData(data, size);

```

#### EBO(Element Buffer Object 索引缓冲)

有些顶点可以被复用来节省空间。通过索引缓冲 + 顶点缓冲，我们可以实现顶点的复用，减少带宽增加性能。
将顶点和索引重组的过程将在渲染时的 Vertex Specification / Input Assembly 流水线阶段自动执行。

```cpp
const std::vector<uint16_t> indices = { // indexing range: [0, 65535)
    0, 1, 2, 2, 3, 0
};

auto* ebo = std::make_unique<IndexBuffer>(indices);
```

#### UBO

#### SSBO

### image

#### texture

纹理分为2D纹理和cubeMap纹理, 2D纹理必须是一张正方形的纹理, 其长宽必须是2的整数次幂, 

#### Image Load Storage

[wiki](https://www.khronos.org/opengl/wiki/Image_Load_Store)

### shader stage


### render pass

`render pass`可以看作是对渲染过程的一个描述，例如这次渲染是否需要颜色组件，深度组件等,
`render pass`在创建的时候需要指定其需要的组件，但是`RenderPass`并不拥有这些组件,
这些组件可能在其他地方, 如`frame buffer`。

> `Render Pass`这个概念其实是现代图形 API（Direct3D 12, Vulkan, Metal）的概念。在过去，
> 我们只需要将创建好的`Render Targets`绑定到 Pipeline 即可，例如 DX11 的 OMSetRenderTargets，
> 或者 OpenGL 的 glBindFramebuffer 等。但对于那些支持片上缓存的硬件渲染器（TBDR）来说，
> 它们在使用 Framebuffer 之前可能会先将显存里的纹理加载（Load）到片上缓存空间中，
> 在渲染完毕之后写回（Store）到显存上，这对于使用 TBDR 的移动设备芯片的带宽是有一定挑战的，
> 并且带宽消耗直接反映在发热上。在 OpenGL ES 3 上引入了 glInvalidateFramebuffer() API，
> 调用后当前 Framebuffer attachment 会被标记为“废除”，在 TBDR 平台将不会把数据写回内存。
> 但对于现代图形 API 来说，我们可以直接在 Render Pass 上指定 Render Target 是否读入/写回显存。
> 对于那些渲染时不需要考虑这个 Render Target 之前结果的情景来说，
> 可以选择不关心（VK_ATTACHMENT_LOAD_OP_DONT_CARE）该纹理在显存中的内容；
> 那些渲染后也不需要写回显存的 Render Target
>（例如一个临时的深度缓存，其只负责辅助当前 Render Pass 进行遮挡判断），
> 也可以设置为 VK_ATTACHMENT_STORE_OP_DONT_CARE，在该 Render Pass 结束后，缓存中的内容将可能被丢弃。
> 当然对于那些均为 DONT_CARE 的，只会存在于片上缓存的纹理资源来说，可以将其设置为 
> Transient Attachments（TRANSIENT_ATTACHMENT_BIT），这样的话，纹理甚至不会存在于内存中，
> 当然，Render Pass 的设计初衷也不仅仅是为了优化 TBDR 的渲染效率。
> 当驱动在渲染前事先知道了 Render Pass 的流程状态，其可能可以进行一些优化。

在执行时`render pass`会从这里拿到相应的组件，
并将结果绘制到`framebuffer`中(类似于`OpenGL`中对`FrameBuffer`的一次`Bind`和一次`UnBind`)。

`render pass`并不需要定义完整的绘制流程，其绘制流程在`command buffer`中设置,
这样的目的是为了增加灵活性, 而`render pass`在绘制的时候只需要绑定到相关的`command buffer`即可.

以下代码展示了如何创建一个`RenderPass`

``` cpp

struct AttachmentDescription {
  int type;
  int format;
};

struct RenderPassCreateInfo {
  bool colorAttachment = true;
  bool depthAttachment = true;

  // OTHERS
  ...
};

RenderPassCreateInfo createInfo;
auto renderPass = std::make_unique<RenderPass>(createInfo);
```

> **目前没有实现subpass的打算**

理论上来说一个renderpass上面可以有多个subpass, 关于`subpass`可以阅读
[这篇介绍](https://gavinkg.github.io/ILearnVulkanFromScratch-CN/mdroot/Vulkan%20%E8%BF%9B%E9%98%B6/Subpass/Subpass%20%E5%88%9D%E6%AD%A5.html)

OpenGL没有提供subpass的功能, 可以使用`Pixel Local Storage`模拟实现, 可以查看
[这篇文章](https://blog.csdn.net/zju_fish1996/article/details/112847781)作为参考

### frame buffer

Framebuffer为一组(一个或多个)`Attachments`的集合。`frame buffer`在创建的时候需要一个`Render Pass`,
其目的是为了获取`Render Pass`中关于`Attachments`的信息，例如是否需要深度，颜色等。

以下代码展示了如何创建一个`frame buffer`

``` cpp
struct FrameBufferCreateInfo {
  RenderPass* renderPass;

  int width;
  int heigh;

  std::shared_ptr<Texture> colorAttachment;  // 如果需要绘制颜色, 将颜色绘制到此处
  std::shared_ptr<Texture> depthAttachment;  // 如果需要绘制深度, 将颜色绘制到此处
};

RenderPassCreateInfo renderPassCreateInfo;
auto renderPass = std::make_unique<RenderPass>(renderPassCreateInfo);

FrameBufferCreateInfo frameBufferCreateInfo {
  .renderPass = renderPass.get()

  // SET attachment
  ...
};
auto frameBuffer = std::make_unique<FrameBuffer>(renderPass);
```

### Descriptor Set

#### Descriptor

`Descriptor`是用来向`pipeline`中传递的全局数据, 可以是一下几种类型:

1. Image
2. Buffer

其中`Buffer`有`UBO`和`SSBO`两种, 而`Image`主要是指`Texture`

每一个`Descriptor`都需要指定一个绑定点

#### Descriptor Set

每条`pipeline` 中可以有多个`Descriptor`, 这些`Descriptor`被称为`Descriptor Set`。

`Descriptor`被存放在一个`Descriptor Pool`的地方, 一个`Descriptor Pool`可以有多个`SubPool`,
一个`SubPool`用来存放所有相同类型的`Descriptor`。默认`Descriptor Pool`是存放在`RHIFactor`中的,
所以不需要手动创建

一下代码展示了创建一个`DescriptorSet`和绑定一个`UBO`的过程:

``` cpp
struct DescriptorInfo {
  DescriptorType type;
  uint32_t bindingPoint;
};

struct DescriptorSetInfo {
  std::vector<DescriptorInfo> descriptors;
};

struct DescriptorPoolInfo {  // 在配置RHIFactor的时候使用
  std::unoridered_map<SubPoolType, int> subpoolInfo = {
    { SAMPLER, 100 },
    { SAMPLED_IMAGE, 100 },
    { STORAGE_IMAGE, 100 },
    { UNIFORM_BUFFER, 100 },
    { UNIFORM_BUFFER_DYNAMIC, 100 },
  };

  uint32_t maxSetCount = 16;
};


UniformBuffer* ubo; // create elsewhere

DescriptorInfo descriptorInfo {
  .type = UNIFORM_BUFFER,
  .bindingPoint = 0,
};

DescriptorSetInfo descriptorSetInfo {
  .descriptors = { descriptorInfo },
};

auto descriptorSet = rhiFactor->GetDescriptorSet(descriptorSetInfo);
descriptorSet->bind(bindingPoint, ubo);
```

### 渲染管线(Pipeline)

渲染管线有如下类型

1. GraphicsPipeLine

传统的光栅化渲染管线, 在一条pipeline中, 需要配置如下信息:

  1. shader
  2. VAO, VBO, EBO, 以及相关的绘制信息
  3. viewport
  4. 裁剪信息
  5. 光栅化器配置信息(深度信息是否归一化到[0, 1]，多边形呈现方法，正面判定方法，culling mode 等)
  6. 是否使用MSAA
  7. 是否启动深度测度和模板测试
  8. 是否启动以及配置混合方式
  9. 配置`Descriptor Set Info`
  10. 配置renderpass

`GraphicsPipeLine` 应该还能够支持缓存和复用, 暂时还未实现这些功能

`GraphicsPipeLine`的示例代码如下

``` cpp

struct ViewportInfo {
  uint32_t x;
  uint32_t y;
  uint32_t width;
  uint32_t height;
  uint32_t minDepth;
  uint32_t maxDepth;
};

struct ScissorInfo {
  uint32_t x;
  uint32_t y;
  uint32_t width;
  uint32_t height;
};

struct RasterizationInfo {
  bool depthClampEnable; // TODO
  bool rasterizerDiscardEnable; // TODO
  PolygonMode polygonMode;
  float lineWidth = 1.0f;
  CullMode cullMode;
  FrontFace frontFace;
  bool depthBiasEnable; // TODO
};

struct DepthStencilInfo {
  bool depthTestEnable;
  bool depthWriteEnable;
  DepthCompareOp depthCompareOp;
  bool depthBoundsTestEnable;
  bool stencilTestEnable;
};

struct MultisampleInfo {
  bool sampleShadingEnable = VK_FALSE;
  // rasterizationSamples = VK_SAMPLE_COUNT_1_BIT;
};

struct BlendInfo {
  bool blendEnable;
  BlendOp logicOp;
};

struct PipelineInfo{
  VertexInputDescription vertexInputDescription;
  ViewportInfo viewport;
  ScissorInfo scissor;
  DescriptorSetInfo descriptorsSetInfo;
  MultisampleInfo multisampleInfo;
};

```

### command, command Buffer

command是一系列GPU指令, 所有的Command都继承自`ICommand`目前有以下几种

1. Begin/End Renderpass
这条命令的主要目的是为了获取renderpass中的framebuffer, 用于告诉GPU具体的渲染位置,
同时也是为了和Vulkan中的API统一

2. Bind Pipeline
这条命令的主要目的是为了获取`pipeline`中的shader等信息, 同时也是为了和Vulkan中的API统一

3. Bind VertexBuffers

4. Bind DescriptorSets

5. set viewport

6. draw index

`command buffer`是`command`的集合, 用于设置`command`的执行顺序, 同时将命令提交到GPU。
重置`command Buffer`可以将之前录制的命令清空


## 设计参考资料

1. [Vulkan学习笔记](https://gavinkg.github.io/ILearnVulkanFromScratch-CN/)
2. [OpenGL Wiki](https://www.khronos.org/opengl/wiki/)
