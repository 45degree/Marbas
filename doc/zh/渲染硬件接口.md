# 渲染硬件接口(RHI)

渲染硬件接口是对不同平台的图形api的封装, 设计目的是为了方便切换不同平台API, 目前只支持OPENGL,
后续将支持VULKAN。

## 接口定义

### Swap chain

Swap Chain用来在屏幕上展示最终的渲染结果, 其内部负责在每一个显示器的Vblank(可以理解为一次刷新)向
`Surface`输送渲染好的画面，然后把这个画面(已经没用了)来回收, 画面的数量由渲染API决定(OpenGL并没有
显示的定义Swap Chain, 所以只有一个)。

SwapChain的配置参数如下:
  1. width, height
  2. 是否开启垂直同步
  3. Window

``` cpp
class SwapChain {
  std::vector<std::shared_ptr<Texture>> m_textures;

public:
  SwapChain(int width, int height, GLFWWindows* windows);
  std::shared_ptr<Texture> GetCurrentTexture() {
    // IMPL
  }
};
```

需要注意的是, 为了将一个Texture显示到`Surface`, 应该将这张`texture`作为默认`framebuffer`的
`colorAttachment`

### [buffer](https://www.khronos.org/opengl/wiki/Buffer_Object)

#### VAO

#### VBO

#### EBO

#### UBO

#### SSBO

### image

#### texture

纹理分为2D纹理和cubeMap纹理, 2D纹理必须是一张正方形的纹理, 其长宽必须是2的整数次幂, 

#### Image Load Storage

[wiki](https://www.khronos.org/opengl/wiki/Image_Load_Store)

### render pass

`render pass`可以看作是渲染过程中的一个子过程，其输入是各种附加件(如颜色组件，深度组件等)等,
`render pass`在创建的时候需要指定其需要的组建，同时一个renderpass会有一个`framebuffer`, 
在执行时`render pass`会从这里拿到相应的组件，并将结果绘制到`framebuffer`中。
`render pass`并不需要定义完整的绘制流程，其绘制流程在`command buffer`中设置,
这样的目的是为了增加灵活性, 而`render pass`在绘制的时候只需要绑定到相关的`command buffer`即可.

``` cpp
struct RenderPassCreateInfo {
  bool colorAttachment;
  bool depthAttachment;

  // OTHERS
  ...
};

class RenderPass {
  RenderPassCreateInfo info;
  std::unque_ptr<FrameBuffer> m_frameBuffer;
public:

  void Use() {
    if(info.colorAttachment) {
      m_framebuffer->GetColorAttachment()->bind();
    }

    if(info.depthAttachment) {
      m_framebuffer->GetDepthAttachment()->bind();
    }

    // DO OTHER THINGS
    ...
  }

  void UnUse(
    if(info.colorAttachment) {
      m_framebuffer->GetColorAttachment()->unbind();
    }

    if(info.depthAttachment) {
      m_framebuffer->GetDepthAttachment()->unbind();
    }

    // DO OTHER THINGS
    ...
  )
};
```

> **目前没有实现subpass的打算**

理论上来说一个renderpass上面可以有多个subpass, 关于`subpass`可以阅读
[这篇介绍](https://gavinkg.github.io/ILearnVulkanFromScratch-CN/mdroot/Vulkan%20%E8%BF%9B%E9%98%B6/Subpass/Subpass%20%E5%88%9D%E6%AD%A5.html)

OpenGL没有提供subpass的功能, 可以使用`Pixel Local Storage`模拟实现, 可以查看
[这篇文章](https://blog.csdn.net/zju_fish1996/article/details/112847781)作为参考

### Descriptor Set

Descriptor是用来向`pipeline`中传递的全局数据, 可以是一下几种类型:
1. 采样器和纹理(一般一个纹理对应一个采样器)
2. 将采样器和能够采样的纹理对象打包起来，成为一个资源描述，之后会提到。
3. UBO
4. SSBO

每条`pipeline` 中可以有多个Descriptor, 这些`Descriptor`被称为`Descriptor Set`。`Descriptor`被存放在一个
`Descriptor Pool`的地方, 一个`Descriptor Pool`可以有多个`SubPool`,
一个`SubPool`用来存放所有相同类型的`Descriptor`。

每一个`Descriptor`主要分为两个, `buffer`和`image`类型

``` cpp

class DescriptorPool {

};

class DescriptorSets {
  virtual AddDescriptor(IDescriptor* descriptor);
};

class IDescriptor {};

class IImageDescriptor : public IDescriptor {};

class IBufferDescriptor : public IDescriptor {};
```

### command, command Buffer

command是一系列GPU指令, 所有的Command都继承自`ICommand`目前有以下几种

1. Begin/End Renderpass
这条命令的主要目的是为了获取renderpass中的framebuffer, 用于告诉GPU具体的渲染位置,
同时也是为了和Vulkan中的API统一

2. Bind Pipeline
这条命令的主要目的是为了获取`pipeline`中的shader等信息, 同时也是为了和Vulkan中的API统一

3. Bind VertexBuffers

4. Bind DescriptorSets

5. set viewport

6. drawByIndex


`command buffer`是`command`的集合, 用于设置`command`的执行顺序, 同时将命令提交到GPU。
重置`command Buffer`可以将之前录制的命令清空

### 渲染管线(Pipeline)

渲染管线有如下类型

1. GraphicsPipeLine

传统的光栅化渲染管线, 每条渲染管线只有一个`renderpass`, 在一条pipeline中, 需要配置如下信息:

  1. shader
  2. VAO, VBO, EBO, 以及相关的绘制信息
  3. viewport
  4. 裁剪信息
  5. 光栅化器配置信息(深度信息是否归一化到[0, 1]，多边形呈现方法，正面判定方法，culling mode 等)
  6. 是否使用MSAA
  7. 是否启动深度测度和模板测试
  8. 是否启动以及配置混合方式
  9. 配置`Descriptor Set`
  10. 配置renderpass

`GraphicsPipeLine` 应该还能够支持缓存和复用, 暂时还未实现这些功能


## 设计参考资料

1. [Vulkan学习笔记](https://gavinkg.github.io/ILearnVulkanFromScratch-CN/)
2. [OpenGL Wiki](https://www.khronos.org/opengl/wiki/)
